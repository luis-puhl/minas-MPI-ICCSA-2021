
% \begin{algorithm}
%     \DontPrintSemicolon
%     \SetKwFunction{FMain}{Main}
%     \SetKwProg{Fn}{algorithm}{:}{}
%     \Fn{\FMain{$f$, $a$, $b$, $\varepsilon$}}{
%           a\;
%           b\;
%           \KwRet\;
%     }
%     \;
%     \SetKwProg{Pn}{algorithm}{:}{\KwRet}
%     \Pn{\FMain{$f$, $a$, $b$, $\varepsilon$}}{
%           a\;
%           b\;
%     }
% \end{algorithm}
% \IncMargin{1em}
\begin{algorithm}[h]
% \begin{multicols}{2}
    \SetKwProg{KwFunction}{algorithm}{:}{}
    % \DontPrintSemicolon
    % \KwIn{sample, ModelSet, params as p}
    % \KwOut{Classified Sample}
    % 
    \SetKwData{CW}{cleaningWindow}
    \SetKwData{NDT}{noveltyDetectionTrigger}
    \SetKwData{MEPC}{minExamplesPerCluster}
    \SetKwData{NF}{noveltyFactor}
    % 
    % \KwSty{Parameters}: cleaningWindow as \CW,
    % noveltyDetectionTrigger as \NDT,
    % minExamplesPerCluster as \MEPC,
    % noveltyFactor as \NF\\
    % 
    \SetKwFunction{nearestCluster}{nearestCluster}
    \SetKwFunction{clustering}{clustering}
    \SetKwFunction{sizeOf}{sizeOf}
    \SetKwFunction{NoveltyDetection}{NoveltyDetection}
    \SetKwFunction{handleModelSleep}{moveToSleep}
    \SetKwFunction{removeOldSamples}{removeOldSamples}
    % 
    % \KwData{ UnkownSet $\leftarrow$ $\emptyset$, ModelSleepSet $\leftarrow$ $\emptyset$, lastCleanupTime $\leftarrow$ now() }
    % 
    \KwFunction{\NoveltyDetection{Model, Samples}}{
        newModelSet $\leftarrow$ $\emptyset$\;
        \ForEach{cl in \clustering(Samples)}{
            \If{$|cl.sampleSet| \geq$ \MEPC}{
                (distance, near) $\leftarrow$ \nearestCluster(cl, Model)\;
                \eIf{distance $<$ near.radius $\times$ \NF}{
                    cl.label $\leftarrow$ near.label\;
                    cl.type $\leftarrow$ extension\;
                }{
                    cl.label $\leftarrow$ noveltyIndex\;
                    noveltyIndex $\leftarrow$ noveltyIndex $+ 1$\;
                    cl.type $\leftarrow$ novelty\;
                }
                Samples $\leftarrow$ Samples $\ominus$ cl.sampleSet\;
                newModelSet $\leftarrow$ newModelSet $\oplus$ cl\;
            }
        }
        \Return{newModelSet}
    }
    \label{alg:MINAS-nd}
    \caption{Minas: Novelty Detection task.}
\end{algorithm}
\begin{algorithm}
    \SetKwProg{KwFunction}{algorithm}{:}{}
    % \DontPrintSemicolon
    % \KwIn{sample, ModelSet, params as p}
    % \KwOut{Classified Sample}
    % 
    \SetKwData{CW}{cleaningWindow}
    \SetKwData{NDT}{noveltyDetectionTrigger}
    \SetKwData{MEPC}{minExamplesPerCluster}
    \SetKwData{NF}{noveltyFactor}
    % 
    % \KwSty{Parameters}: cleaningWindow as \CW,
    % noveltyDetectionTrigger as \NDT,
    % minExamplesPerCluster as \MEPC,
    % noveltyFactor as \NF\\
    % 
    \SetKwFunction{nearestCluster}{nearestCluster}
    \SetKwFunction{clustering}{clustering}
    \SetKwFunction{sizeOf}{sizeOf}
    \SetKwFunction{NoveltyDetection}{NoveltyDetection}
    \SetKwFunction{handleModelSleep}{moveToSleep}
    \SetKwFunction{removeOldSamples}{removeOldSamples}
    % 
    \SetKwProg{algorithm}{algorithm}{:}{}
    \SetKwFor{With}{with}{}{}
    \SetKw{continue}{continue}
    % 
    \SetKwData{CW}{CW}
    \SetKwData{noveltyDetectionTrigger}{NDT}
    \SetKwData{MEPC}{MEPC}
    \SetKwData{NF}{NF}
    \SetKwData{mpiSize}{mpiSize}
    \SetKwData{mpiRank}{mpiRank}
    \SetKwData{EndOfStream}{EndOfStream}
    % 
    \KwIn{ModelSet, Sample Stream}
    \KwOut{Classified Stream as $out$}
    \SetKwFunction{MinasOnline}{MinasOnline}
    \KwFunction{\MinasOnline{ModelSet, SampleStream}}{
        UnkownSet $\leftarrow$ $\emptyset$, ModelSleepSet $\leftarrow$ $\emptyset$ \;
        lastCleanup $\leftarrow 0$ , noveltyIndex $\leftarrow 0$\;
        % sampleIn $\leftarrow 0$\;
        \ForEach{ {$sample_{i}$} $\in$ SampleStream }{
            % sample.label $\leftarrow$ unknown\;
            % (distance, cluster) $\leftarrow$ \nearestCluster(sample, ModelSet)\;
            nearest $\leftarrow$ \nearestCluster(sample, ModelSet)\;
            \eIf{nearest.distance $<$ nearest.cluster.radius}{
                sample.label $\leftarrow$ nearest.cluster.label\;
                nearest.cluster.lastUsed $ \leftarrow i $ \;
                % $out \leftarrow$ sample\;
                % outputStream.append(sample);
                % \textbf{continue};
                % \Return sample\;
            }
            {
                sample.label $\leftarrow$ unknown\;
                UnkownSet $\leftarrow$ UnkownSet $\cup$ sample\;
                \If{$|UnkownSet| \geq$ \NDT}{
                    % \tcc{Novelty Detection}
                    novelties $\leftarrow$ \NoveltyDetection(ModelSet $\cup$ ModelSleepSet, *UnkownSet)\;
                    ModelSet $\leftarrow$ ModelSet $\cup$ novelties\;
                }
                \If{ $ i > $ ( lastCleanup $ + $ \CW )}{
                    ModelSet $\leftarrow$ \handleModelSleep(ModelSet, *ModelSleepSet, lastCleanup)\;
                    UnkownSet $\leftarrow$ \removeOldSamples(UnkownSet, lastCleanup)\;
                    lastCleanup $ \leftarrow i $\;
                }
                % \Return sample\;
            }
            outputStream.append(sample);
            % $out \leftarrow$ sample\;
        }
    }
% \end{multicols}
% }
\label{alg:MINAS}
\caption{Our interpretation of MINAS \cite{faria2013novelty,Faria2016minas,Cassales2019a}}
\end{algorithm}
% \DecMargin{1em}


% --------------------------------------------------------------------------------------------------

% \begin{algorithm}[ht]
%   \caption{MINAS \cite{Faria2016minas,Cassales2019a}}
%   \label{alg:MINAS}
%   \renewcommand{\algorithmicrequire}{\textbf{Entrada:}}
%   \begin{algorithmic}[1]
%     %T $\leftarrow$ limiar de distância para pertencer ao grupo
%     %P $\leftarrow$ tempo de "inatividade" para passar para memória sleep
%     %ts $\leftarrow$ limiar para remoção de exemplos da memória temporária
%     \REQUIRE $Modelo,FCD,T,NumMinExemplos,ts,P$
%     \STATE $MemTmp \leftarrow \emptyset$
%     \STATE $MemSleep \leftarrow \emptyset$
%     \FORALL{$exemplo \in FCD$}
%     \STATE $(Dist,micro) \leftarrow$ micro-mais-proximo($exemplo,Modelo$)
%     \IF{$Dist < $ raio($micro$)}
%     \STATE $exemplo.classe \leftarrow micro.rotulo$
%     \STATE atualizar-micro($micro,exemplo$)
%     \ELSE
%     \STATE $exemplo.classe \leftarrow desconhecido$
%     \STATE $MemTmp \leftarrow MemTmp \cup exemplo$
%     \IF{$|MemTmp| \geq NumMinExemplos$}
%     \STATE $Modelo \leftarrow $ deteccao-novidade($Modelo,MemTmp,T$)
%     \ENDIF
%     \ENDIF
%     \STATE $TempoAtual \leftarrow exemplo.T$
%     \IF{$TempoAtual$ mod $TamJanela == 0$}
%     \STATE $Modelo \leftarrow$ mover-micro-grupos-mem-sleep($Modelo,MemSleep,P$)
%     \STATE $MemTmp \leftarrow$ remover-exemplos-antigos($MemTmp,ts$)
%     \ENDIF
%     \ENDFOR
%   \end{algorithmic}
% \end{algorithm}

% \begin{algorithm}[ht]
%   \caption{MINAS \cite{Faria2016minas,Cassales2019a}}
%   \label{alg:MINAS}
%   \renewcommand{\algorithmicrequire}{\textbf{Entrada:}}
%   \begin{algorithmic}[1]
%   \IF{root}
%     \WHILE{true}
%     \IF{can_read(S)}
%     input(S, $s$)
%     send(s, i++)
%     \ENDIF
%     \IF{can_rcv($(s, l)$, any)}
%         output($(s, l)$)
%         \IF{$l == '-'$ )}
%             store($(s, l)$, unknowns)
%             % \IF{$|MemTmp| \geq NumMinExemplos$}
%             % \STATE $Modelo \leftarrow $ deteccao-novidade($Modelo,MemTmp,T$)
%             % \ENDIF
%             % \ENDIF
%             % \STATE $TempoAtual \leftarrow exemplo.T$
%             % \IF{$TempoAtual$ mod $TamJanela == 0$}
%             % \STATE $Modelo \leftarrow$ mover-micro-grupos-mem-sleep($Modelo,MemSleep,P$)
%             % \STATE $MemTmp \leftarrow$ remover-exemplos-antigos($MemTmp,ts$)
%             % \ENDIF
%         \ENDIF
%     \ENDIF
%   \ENDWHILE
%   \ENDIF
%   \IF{leaf}
%     rcv($s$, root)
%     $l$ $\leftarrow$ classify($s$)
%     send($(s, l)$, root)
%   \ENDIF
%   \end{algorithmic}
% \end{algorithm}

% \begin{algorithm}
%   \caption{High level parallel algorithm}
%   \label{alg:highlevel-new}
%   \begin{algorithmic}[1]
%     \State {\bf Input}: an ensemble $E$, $num\_threads$, a data stream $S$
%     \State $P \gets Create\_service\_thread\_pool(num\_threads)$
%     \State $T \gets Create\_trainers\_collection(E)$
%     \For {each arriving instance $I$ in stream $S$}
%     \State $E$.classify($I$)
%     \For  {each trainer $T_i$ in trainers $T$} 
%     \State $k \gets poisson(\lambda)$
%     \State $T_i.update(I, k)$
%     \EndFor
%     \For {all trainers $T$} {\bf in parallel}
%     \State $W\_inst \gets I * k$
%     \State $Train\_on\_instance(W\_inst)$
%     \EndFor
%     \If {change detected}
%     \State $reset\_classifier$
%     \EndIf
%     \EndFor
%   \end{algorithmic}
% \end{algorithm}

